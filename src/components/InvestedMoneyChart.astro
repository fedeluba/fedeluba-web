---
import financesData from '../data/finances.yaml';

interface FinancesData {
  currency: string;
  goal: number;
  holdings: any[];
  history: { month: string; amount: number }[];
}

const finances = financesData as FinancesData;

// Sort history by month (oldest first for chart)
const sortedHistory = [...finances.history].sort((a, b) => a.month.localeCompare(b.month));

// Use last historical value as fallback
const lastHistoricalValue = finances.history[0]?.amount || 0;

const formattedGoal = new Intl.NumberFormat('en-US', {
  style: 'currency',
  currency: finances.currency,
  minimumFractionDigits: 0,
  maximumFractionDigits: 0,
}).format(finances.goal);

// Format month for display
const formatMonth = (monthStr: string) => {
  const [year, month] = monthStr.split('-');
  const date = new Date(parseInt(year), parseInt(month) - 1);
  return date.toLocaleDateString('en-US', { month: 'short' });
};

// Chart dimensions
const chartWidth = 280;
const chartHeight = 70;
const padding = { top: 8, right: 8, bottom: 8, left: 6 };
const innerWidth = chartWidth - padding.left - padding.right;
const innerHeight = chartHeight - padding.top - padding.bottom;

// Calculate chart points
const values = sortedHistory.map(h => h.amount);
const maxVal = Math.max(...values) * 1.05;
const minVal = Math.min(...values) * 0.95;
const range = maxVal - minVal;

const points = sortedHistory.map((entry, i) => {
  const x = padding.left + (i / (sortedHistory.length - 1)) * innerWidth;
  const y = padding.top + innerHeight - ((entry.amount - minVal) / range) * innerHeight;
  return { x, y, value: entry.amount, month: formatMonth(entry.month) };
});

// Create SVG path
const pathD = points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');

// Create area path (for gradient fill)
const areaD = `${pathD} L ${points[points.length - 1].x} ${chartHeight - padding.bottom} L ${points[0].x} ${chartHeight - padding.bottom} Z`;
---

<div class="rounded-xl border border-[var(--color-border)] bg-[var(--color-card)] overflow-hidden">
  <!-- Header -->
  <div class="px-5 py-4 border-b border-[var(--color-border)] flex items-center justify-between">
    <span class="text-sm text-[var(--color-text-muted)]">Portfolio</span>
    <span 
      id="change-badge"
      class="inline-flex items-center gap-1.5 rounded-full px-3 py-1 text-sm font-mono font-medium bg-green-500/10 text-[var(--color-success)]"
    >
      <svg id="change-icon" class="size-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5">
        <path d="M5 10l7-7m0 0l7 7m-7-7v18" />
      </svg>
      <span id="change-text">...</span>
    </span>
  </div>
  
  <div class="p-5">
    <!-- Value -->
    <div class="mb-4">
      <p id="total-value" class="font-mono text-3xl font-semibold text-[var(--color-text)]">
        <span class="inline-block w-32 h-9 bg-[var(--color-bg-secondary)] rounded animate-pulse"></span>
      </p>
      <p id="last-updated" class="text-xs text-[var(--color-text-muted)] mt-1 opacity-0 transition-opacity duration-300"></p>
    </div>
    
    <!-- Line Chart -->
    <div class="mb-5 relative">
      <svg 
        id="line-chart" 
        viewBox={`0 0 ${chartWidth} ${chartHeight}`} 
        class="w-full h-auto"
      >
        <!-- Gradient definition -->
        <defs>
          <linearGradient id="areaGradient" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color: var(--color-accent); stop-opacity: 0.3" />
            <stop offset="100%" style="stop-color: var(--color-accent); stop-opacity: 0" />
          </linearGradient>
        </defs>
        
        <!-- Area fill -->
        <path d={areaD} fill="url(#areaGradient)" />
        
        <!-- Line -->
        <path 
          d={pathD} 
          fill="none" 
          stroke="var(--color-accent)" 
          stroke-width="2" 
          stroke-linecap="round" 
          stroke-linejoin="round"
        />
        
        <!-- Interactive points -->
        {points.map((point, i) => (
          <g class="chart-point" data-index={i} data-value={point.value} data-month={point.month}>
            <!-- Larger invisible hit area -->
            <circle 
              cx={point.x} 
              cy={point.y} 
              r="12" 
              fill="transparent" 
              class="cursor-pointer"
            />
            <!-- Visible dot -->
            <circle 
              cx={point.x} 
              cy={point.y} 
              r={i === points.length - 1 ? 3 : 2}
              fill={i === points.length - 1 ? "var(--color-accent-hover)" : "var(--color-accent)"}
              class="transition-all duration-200"
              data-dot={i}
            />
          </g>
        ))}
      </svg>
      
      <!-- Tooltip -->
      <div 
        id="chart-tooltip" 
        class="absolute pointer-events-none opacity-0 transition-opacity duration-150 bg-[var(--color-card)] border border-[var(--color-border)] rounded-lg px-3 py-2 shadow-lg z-10"
        style="transform: translate(-50%, -100%); margin-top: -8px;"
      >
        <p id="tooltip-value" class="font-mono text-sm font-semibold text-[var(--color-text)]"></p>
        <p id="tooltip-month" class="text-xs text-[var(--color-text-muted)]"></p>
      </div>
    </div>
    
    <!-- Progress to Goal -->
    <div class="pt-4 border-t border-[var(--color-border)]">
      <div class="flex items-center justify-between text-xs text-[var(--color-text-muted)] mb-2">
        <span>Progress to goal</span>
        <span id="progress-text" class="font-mono">0%</span>
      </div>
      <div class="h-2 overflow-hidden rounded-full bg-[var(--color-bg-secondary)]">
        <div 
          id="progress-bar"
          class="h-full rounded-full bg-gradient-to-r from-[var(--color-accent)] to-[var(--color-accent-hover)] transition-all duration-1000 ease-out"
          style="width: 0%"
        />
      </div>
      <div class="mt-2 flex items-center justify-between text-xs text-[var(--color-text-muted)]">
        <span>$0</span>
        <span>Goal: {formattedGoal}</span>
      </div>
    </div>
  </div>
</div>

<script is:inline define:vars={{ goal: finances.goal, lastHistoricalValue, currency: finances.currency, historyData: sortedHistory, chartWidth, chartHeight, padding }}>
  async function fetchPortfolio() {
    try {
      const response = await fetch('/api/portfolio');
      if (!response.ok) throw new Error('Failed to fetch');
      return await response.json();
    } catch (error) {
      console.error('Portfolio fetch error:', error);
      return null;
    }
  }
  
  function formatCurrency(value) {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: currency,
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    }).format(value);
  }
  
  // Setup tooltip interactions
  function setupTooltips() {
    const tooltip = document.getElementById('chart-tooltip');
    const tooltipValue = document.getElementById('tooltip-value');
    const tooltipMonth = document.getElementById('tooltip-month');
    const chartPoints = document.querySelectorAll('.chart-point');
    const svg = document.getElementById('line-chart');
    
    if (!tooltip || !tooltipValue || !tooltipMonth || !svg) return;
    
    chartPoints.forEach((point) => {
      const value = parseFloat(point.getAttribute('data-value'));
      const month = point.getAttribute('data-month');
      const index = parseInt(point.getAttribute('data-index'));
      const dot = point.querySelector(`[data-dot="${index}"]`);
      
      point.addEventListener('mouseenter', (e) => {
        tooltipValue.textContent = formatCurrency(value);
        tooltipMonth.textContent = month;
        tooltip.style.opacity = '1';
        
        // Position tooltip
        const rect = svg.getBoundingClientRect();
        const circle = point.querySelector('circle');
        const cx = parseFloat(circle.getAttribute('cx'));
        const cy = parseFloat(circle.getAttribute('cy'));
        
        const xPercent = cx / chartWidth;
        const yPercent = cy / chartHeight;
        
        tooltip.style.left = `${xPercent * 100}%`;
        tooltip.style.top = `${yPercent * 100}%`;
        
        // Enlarge dot on hover
        if (dot) {
          dot.setAttribute('r', '4');
        }
      });
      
      point.addEventListener('mouseleave', () => {
        tooltip.style.opacity = '0';
        
        // Reset dot size
        if (dot) {
          const isLast = index === historyData.length - 1;
          dot.setAttribute('r', isLast ? '3' : '2');
        }
      });
    });
  }
  
  async function updateChart() {
    const data = await fetchPortfolio();
    
    const totalValueEl = document.getElementById('total-value');
    const changeBadge = document.getElementById('change-badge');
    const changeIcon = document.getElementById('change-icon');
    const changeText = document.getElementById('change-text');
    const progressText = document.getElementById('progress-text');
    const progressBar = document.getElementById('progress-bar');
    const lastUpdatedEl = document.getElementById('last-updated');
    
    if (data && data.totalValue !== undefined) {
      const totalValue = data.totalValue;
      const progress = Math.min((totalValue / goal) * 100, 100);
      
      // Calculate change from last historical value
      const change = totalValue - lastHistoricalValue;
      const changePercent = lastHistoricalValue > 0 ? ((change / lastHistoricalValue) * 100).toFixed(1) : 0;
      const isPositive = change >= 0;
      
      // Update total value
      totalValueEl.textContent = formatCurrency(totalValue);
      
      // Update change badge
      changeBadge.className = `inline-flex items-center gap-1.5 rounded-full px-3 py-1 text-sm font-mono font-medium ${isPositive ? 'bg-green-500/10 text-[var(--color-success)]' : 'bg-red-500/10 text-red-500'}`;
      changeIcon.innerHTML = isPositive 
        ? '<path d="M5 10l7-7m0 0l7 7m-7-7v18" />'
        : '<path d="M19 14l-7 7m0 0l-7-7m7 7V3" />';
      changeText.textContent = `${Math.abs(changePercent)}%`;
      
      // Update progress
      progressText.textContent = `${progress.toFixed(1)}%`;
      progressBar.style.width = `${progress}%`;
      
      // Update last updated
      const lastUpdated = new Date(data.lastUpdated);
      lastUpdatedEl.textContent = `Last updated: ${lastUpdated.toLocaleTimeString()}${data.cached ? ' (cached)' : ''}`;
      lastUpdatedEl.style.opacity = '1';
      
      // Update the last point's value in tooltip data
      const lastPoint = document.querySelector(`.chart-point[data-index="${historyData.length - 1}"]`);
      if (lastPoint) {
        lastPoint.setAttribute('data-value', totalValue.toString());
      }
    } else {
      // Fallback to historical value
      totalValueEl.textContent = formatCurrency(lastHistoricalValue);
      changeText.textContent = 'Offline';
      changeBadge.className = 'inline-flex items-center gap-1.5 rounded-full px-3 py-1 text-sm font-mono font-medium bg-[var(--color-bg-secondary)] text-[var(--color-text-muted)]';
      changeIcon.innerHTML = '';
      
      const progress = Math.min((lastHistoricalValue / goal) * 100, 100);
      progressText.textContent = `${progress.toFixed(1)}%`;
      progressBar.style.width = `${progress}%`;
    }
  }
  
  // Setup tooltips on load
  setupTooltips();
  
  // Fetch on load
  updateChart();
  
  // Re-fetch and re-setup after view transitions
  document.addEventListener('astro:after-swap', () => {
    setupTooltips();
    updateChart();
  });
</script>
